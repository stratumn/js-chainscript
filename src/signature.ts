// Copyright 2017-2018 Stratumn SAS. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { sig } from "@stratumn/js-crypto";
import * as b64 from "base64-js";
import { Base64 } from "js-base64";
import * as constants from "./const";
import * as errors from "./errors";
import { Link } from "./link";
import { stratumn } from "./proto/chainscript_pb";

/**
 * Sign bytes with the current signature version.
 * @param key private key in PEM format (generated by @stratumn/js-crypto).
 * @param toSign bytes that should be signed.
 */
export function sign(key: Uint8Array, toSign: Uint8Array): Signature {
  const privateKey = new sig.SigningPrivateKey({
    pemPrivateKey: key
  });

  const signature = privateKey.sign(toSign);

  const s = new stratumn.chainscript.Signature();
  s.version = constants.SIGNATURE_VERSION;
  s.publicKey = signature.public_key;
  s.signature = signature.signature;

  return new Signature(s);
}

/**
 * Sign configurable parts of the given link with the current signature
 * version.
 * The payloadPath is used to select what parts of the link need to be signed
 * with the given private key. If no payloadPath is provided, the whole link
 * is signed.
 * @param key private key in PEM format (generated by @stratumn/js-crypto).
 * @param link that should be signed.
 * @param payloadPath link parts that should be signed.
 */
export function signLink(
  key: Uint8Array,
  link: Link,
  payloadPath: string
): Signature {
  // We want to make it explicit when we're signing the whole link.
  payloadPath = payloadPath || "[version,data,meta]";

  const toSign = link.signedBytes(constants.SIGNATURE_VERSION, payloadPath);
  const signature = sign(key, toSign);

  const s = new stratumn.chainscript.Signature();
  s.version = signature.version();
  s.payloadPath = payloadPath;
  s.publicKey = signature.publicKey();
  s.signature = signature.signature();

  return new Signature(s);
}

/**
 * A signature of configurable parts of a link.
 * Different signature types and versions are allowed to sign different
 * encodings of the data, but we recommend signing a hash of the
 * protobuf-encoded bytes.
 */
export class Signature {
  private s: stratumn.chainscript.ISignature;

  constructor(s: stratumn.chainscript.ISignature) {
    this.s = s;
  }

  /**
   * @returns the version of the signature scheme.
   */
  public version(): string {
    return this.s.version || "";
  }

  /**
   * @returns the algorithm used (for example, "EdDSA").
   */
  public type(): string {
    return this.s.type || "";
  }

  /**
   * @returns a description of the parts of the link that are signed.
   */
  public payloadPath(): string {
    return this.s.payloadPath || "";
  }

  /**
   * @returns the public key of the signer.
   */
  public publicKey(): Uint8Array {
    return this.s.publicKey || new Uint8Array(0);
  }

  /**
   * @returns the signature bytes.
   */
  public signature(): Uint8Array {
    return this.s.signature || new Uint8Array(0);
  }

  /**
   * Validate the signature and throw an exception if invalid.
   * @param link the link signed.
   */
  public validate(link: Link): void {
    if (!this.publicKey() || this.publicKey().length === 0) {
      throw errors.ErrSignaturePublicKeyMissing;
    }

    if (!this.signature() || this.signature().length === 0) {
      throw errors.ErrSignatureMissing;
    }

    switch (this.version()) {
      case constants.SIGNATURE_VERSION_1_0_0:
        const signed = link.signedBytes(this.version(), this.payloadPath());
        const publicKey = new sig.SigningPublicKey({
          pemPublicKey: Base64.atob(b64.fromByteArray(this.publicKey()))
        });

        const valid = publicKey.verify({
          message: signed,
          signature: this.signature()
        });

        if (!valid) {
          throw errors.ErrSignatureInvalid;
        }
        return;
      default:
        throw errors.ErrSignatureVersionUnknown;
    }
  }
}
